[
  {
    "id": 1,
    "headId": "css-big-picture",
    "headHref": "#css-big-picture",
    "headName": "CSS 개관",
    "folder": "CSS",
    "picture": "css001개관.png",
    "p1": "css의 큰그림은 3가지 영역이다!",
    "p2": "1. 기본 재료들",
    "p3": "2. 재료들은 어떻게 배치할 것인가",
    "p4": "-> 크기지정 vs 크기지정 X",
    "p5": "3. 화면크기에 따른 유동성과 요소의 동적임"
  },
  {
    "id": 2,
    "headId": "css-factor",
    "headHref": "#css-factor",
    "headName": "요소, 부모 자식",
    "folder": "CSS",
    "picture": "css002요소부모자식.png",
    "p1": "웹에 넣는 요소는 크게 3가지이다",
    "p2": "글자, 이미지, 빈칸(너비, 높이 지정 해야함)",
    "p6": "부모에서 자식으로 스타일이 전달된다 핵심은 스타일이 필요한 대상이 누구인가 ??!!",
    "p7": "부모 -> 부모만 필요하거나 부모,자식 둘다 필요한경우",
    "p8": "자식 -> 자식만 필요한 경우",
    "p11": "스타일의 우선순위는 암기해두자",
    "p12": "동일한 우선순위는 코드상위치가 아래로 갈 수록 우선적이다"
  },
  {
    "id": 3,
    "headId": "css-selector",
    "headHref": "#css-selector",
    "headName": "선택자",
    "folder": "CSS",
    "picture": "css003선택자1.png",
    "p1": "누구에게 스타일을 적용할 것인가 tragetting하는게 선택자이다",
    "p2": "보통은 class를 이용하여 선택을 한다",
    "p6": "기본적으로 선택하는 방법들은 필수임",
    "p7": "기하적으로 선택을 해볼 수 있다 "
  },
  {
    "id": 4,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css004선택자2.png",
    "p1": "사용자의 행동조건에 따른 선택자도 있다",
    "p2": "예를들면, 커서를 올린다던지, 클릭을한다던지, 등의 행동",
    "p6": "사용가능여부는 input태그와 연동하여 사용하기도 한다",
    "p7": "부정은 그것빼고 적용하는 것인데",
    "p8": "이걸 대체할 수 있는 다른 선택자가 없다함"
  },
  {
    "id": 5,
    "headId": "css-box",
    "headHref": "#css-box",
    "headName": "box",
    "folder": "CSS",
    "picture": "css005박스1.png",
    "p1": "박스는 내용요소인 content가 있고",
    "p2": "내용과 경계사이의 공간인 padding이 있다",
    "p3": "padding은 처음에는 없는 공간임을 명심하자",
    "p4": "(ul태그는 초기에 padding이 있긴함... 특이케이스 정도)",
    "p6": "마지막으로 박스바깥은 margin이다",
    "p7": "",
    "p8": "margin은 블록의 레벨에따라 처음에 존재유무가 다르다",
    "p9": "inline, inline-block은 마진이 없다"
  },
  {
    "id": 6,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css006박스2.png",
    "p1": "content -> 내용 요소이다",
    "p2": "너비와 높이를 변화시키면 크기변화 하는게 content이다",
    "p3": "블록의 레벨에 따라 크기가 다르니 알아두자"
  },
  {
    "id": 7,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css007박스3.png",
    "p1": "padding -> content와 border사이 공간이다 ",
    "p2": "처음에는 없음을 알아두자",
    "p6": "padding의 크기변화시 경계의 길이가 변하는 것도 중요함",
    "p7": "padding의 크기변화시 블록의 레벨에 따라",
    "p8": "content의 크기에도 영향을 줄 수 있으니 알아두자"
  },
  {
    "id": 8,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css008박스4.png",
    "p1": "border -> padding이 없으면 바로 content를 둘러싼다",
    "p2": "border상 하 좌 우 유무를 이용하면 border중첩현상을 방지 할 수 있다",
    "p6": "cf) outline은 외곽선인데 outline-offset속성을 음수값을 주면",
    "p7": "외곽선을 박스 안으로 사용 할 수 있다"
  },
  {
    "id": 9,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css009박스5.png",
    "p1": "margin -> 박스바깥의 영역이다",
    "p2": "양쪽 마진은 서로 중첩되지 안고 밀어낸다",
    "p3": "상,하 마진은 서로 중첩이되어 겹치게 된다"
  },
  {
    "id": 10,
    "headId": "css-width-height",
    "headHref": "#css-width-height",
    "headName": "width, height",
    "folder": "CSS",
    "picture": "css010너비높이.png",
    "p1": "너비와 높이는 크기!!! 를 부여하는 매우 중요한 친구들 이다",
    "p2": "단위는 고정값과 상대값이 있는데",
    "p6": "무조건 그 크기만 사용하려면 고정값을 쓰면된다",
    "p7": "화면이나 다른 요소에 대해 상대적으로 크기를 지정하고 싶으면",
    "p8": "상대값을 사용하면 된다",
    "p9": "상대값은 단위마다 누구를 기준으로 할지 중요하다"
  },
  {
    "id": 11,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css011maxmin.png",
    "p1": "너비와 높이의 max,min도 매우 중요하다",
    "p2": "max,min은 요소에 제한을 거는것으로 가장 우선시된다",
    "p6": "우선시??!!",
    "p7": "요소의 크기를 지정할때 여러가지 속성이 겹치게 되는 일이 발생하는데",
    "p8": "이 경우에 누가 요소의 크기를 우선적으로 결정하냐가 포인트이다!!"
  },
  {
    "id": 12,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css012변수.png",
    "p1": "css변수는 전역으로 사용하는 방법과 로컬로 사용하는 방법이 있다",
    "p3": "전역 -> :root 를 사용하여 지정하고",
    "p4": "로컬 -> 부모에서 지정하여 자식에서 사용하는 방식이다",
    "p6": "변수는 색상을 약속된 값으로 사용하는 파렛트에 사용하거나",
    "p7": "calc처럼 숫자 계산을 할 때 사용한다"
  },
  {
    "id": 13,
    "headId": "css-flex",
    "headHref": "#css-flex",
    "headName": "flex",
    "folder": "CSS",
    "picture": "css013플렉스박스1.png",
    "p1": "그림에서 약속 하나 하고 가자!!",
    "p2": "flex를 지정하는 파란색판을 flex판이라 하고",
    "p3": "그안의 빨간색 상자는 box라고 하자",
    "p6": "flex는 공간배치를 수월하게 도와주는데",
    "p7": "flex판 안의 box크기를 지정한것 vs 크기 지정 안한것 차이가 있다",
    "p8": "앞서 크기 지정여부가 중요하다고 강조한 이유가 이런 detail의 차이 때문이다 ",
    "p11": "flex가 배치를 하기 위해서는 당연히 기준이 필요하다!!",
    "p12": "그 기준이 바로 box의 배열 방향을 결정하는 주축",
    "p13": "그리고 주축과 교차하는 방향의 교차축"
  },
  {
    "id": 14,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css014플렉스박스2.png",
    "p1": "flex박스는 크게 2가지 절차가 있다",
    "p2": "1st. 순서",
    "p3": "2nd. 정렬방법",
    "p6": "주축의 방향은 가로인가 세로인가",
    "p7": "1줄만 -> 박스의 크기합이 flex판보다 큰 경우에는 n등분이된다"
  },
  {
    "id": 15,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css015플렉스박스3.png",
    "p1": "2nd. 정렬방법",
    "p3": "justify = 주축에 대한 정렬",
    "p4": "align = 교차축에 대한 정렬"
  },
  {
    "id": 16,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css016플렉스박스4.png",
    "p1": "주축에 대한 정렬방법은",
    "p2": "주로 justify-content를 사용한다",
    "p4": "정렬의 유형은 사진 참고"
  },
  {
    "id": 17,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css017플렉스박스5.png",
    "p1": "교차축에 대한 정렬방법은",
    "p2": "크게 3가지 방식을 사용한다",
    "p4": "align-content는 justify-content와 흡사 해보인다"
  },
  {
    "id": 18,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css018플렉스박스6.png",
    "p1": "align-items는 3가지 방식중 많이 사용한다고 한다",
    "p3": "왜냐, align-content와 달리 start, end, center에서",
    "p4": "서로간 간격을 내기 좋기 때문이다"
  },
  {
    "id": 19,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css019플렉스박스7.png",
    "p1": "align-self는 자식에서 사용하는 속성이다",
    "p3": "플렉스의 보라색 영역에서 각각의 줄마다 내부적으로 배치함"
  },
  {
    "id": 20,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css020플렉스박스8.png",
    "p1": "box의 크기를 지정하지 안은 경우는 어떨까??",
    "p2": "물론 box안의 내용요소들 (예, 문자 )의 크기는 있다",
    "p3": "허나, 중요한건 box공간은 별도로 크기를 주지 안은게 핵심이다",
    "p6": "flex: 1 이라는 속성을 이용하면",
    "p7": "flex판의 주축방향을 n등분하여 나눠줄 수 있다",
    "p8": "근데, 이렇게 되면 1줄만 box들이 가득차게 된다",
    "p11": "앞서 배운 min-width를 사용하면",
    "p12": "box의 크기는 최소한도 너비를 가지게 되어서",
    "p13": "다음줄로 밀려나게 된다"
  },
  {
    "id": 21,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css021그리드1.png",
    "p1": "그리드는 컨테이너의 공간을 나눠사용하는 것이다."
  },
  {
    "id": 22,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css022그리드2.png",
    "p1": "그리드에서도 약속 하나 하자면",
    "p2": "빨간색 상자를 gird판이라고 하고 부모요소라 하자",
    "p3": "그안에 자식으로 공간이 들어간다 까지",
    "p6": "그리드 항목공간의 너비와 높이를 지정해주는데",
    "p7": "상대값은 fr을 이용하여 비율로 표현 가능하다",
    "p9": "grid-template-columns는 width와 가로의 의미가 있는데",
    "p10": "결국은 1줄에 몇개공간 쓰고 각 공간 너비가 얼마냐를 지정해주는 것이다",
    "p11": "flex와 구별되는 특징이라면",
    "p12": "그리드 항목간에의 간격을 내 맘대로 조정이 가능하다"
  },
  {
    "id": 23,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css023그리드3.png",
    "p1": "여러줄이 있고 마치 셀병합을 한 것 처럼",
    "p2": "그리드 항목 공간을 사용하고 싶을 때!!",
    "p6": "grid-template-area를 사용 할 수 있다",
    "p7": "\"  \"를 이용하여 1줄을 표현하고",
    "p8": "시각적으로 구성 할 수 있다는 점에서 유용하다"
  },
  {
    "id": 24,
    "headId": "css-containing-block",
    "headHref": "#css-containing-block",
    "headName": "containing block",
    "folder": "CSS",
    "picture": "css024컨테이닝블록.png",
    "p1": "부모는 조건이 맞아야 자식을 감쌀 수 있다",
    "p2": "그게 아니라면 자식요소의 크기가  큰 경우",
    "p3": "부모의 밖으로 넘치는 현상이 발생할 수 있다",
    "p4": "",
    "p5": "",
    "p6": "containing block은 누가 부모인가를 결정 하는 것이다 ",
    "p7": "가령, 크기의 상대단위인 %는 부모를 기준으로 크기를 결정하는데",
    "p8": "무조건 상위의 요소가 부모는 아니기 때문이다",
    "p9": "그리고 필요하다면 그 상위의 요소가 부모의 역할이 되게 만들어야지",
    "p10": "자유자재로 배치 할 수 있다",
    "p11": "이따 다룰거지만 position 속성을 기준으로 containing block를 정한다",
    "p12": "position의 기본값은 static이고",
    "p13": "이들은 우리가 흔히 알듯이 상위의 요소가 부모들이다",
    "p14": "",
    "p15": "",
    "p16": "하지만 absolute는 static이 부모가 될 수 없어서",
    "p17": "우리가 아는 상위요소를 부모로 보았다가는 원하는 배치를 하기 힘들어진다",
    "p18": "그래서 공식처럼 absolute를 사용하려면 상위요소에 relative를 넣어서",
    "p19": "그 상위요소를 부모로 만드는것이 이러한 이유이다",
    "p20": ""
  },
  {
    "id": 25,
    "headId": "css-block-formatting-context",
    "headHref": "#css-block-formatting-context",
    "headName": "block formatting context",
    "folder": "CSS",
    "picture": "css025블록포멧팅.png",
    "p1": "block formatting context는 어디까지가 자식인가",
    "p6": "이따 다룰거지만 overflow의 경우 기본값이 visible인데",
    "p7": "visible은 자식으로 취급하지 안는다",
    "p8": "이런경우에 자식의 요소가 부모 보다 크기가 커서 넘치는경우가 발생함",
    "p9": "그래서 overflow를 auto혹은 scroll등으로 바꿔주는 것이다"
  },
  {
    "id": 26,
    "headId": "css-position",
    "headHref": "#css-position",
    "headName": "position",
    "folder": "CSS",
    "picture": "css026포지션1.png",
    "p1": "position은 요소가 위로 떠버린다",
    "p2": "css 코드상의 위치가 아래로 갈 수록 더 위로 뜬다",
    "p3": "z-index의 높은숫자로 조절가능함",
    "p6": "position은 주로 자식에 적용을 하는데",
    "p7": "절대위치와 상대위치가 있다"
  },
  {
    "id": 27,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css027포지션2.png",
    "p1": "사진에서 중요하게 봐야할 포인트는 2가지이다!!",
    "p3": "1. 누구를 기준으로 위치를 정하는가",
    "p4": "2. 다른요소에 영향을 주는가"
  },
  {
    "id": 28,
    "headId": "css-overflow",
    "headHref": "#css-overflow",
    "headName": "overflow",
    "folder": "CSS",
    "picture": "css028overflow.png",
    "p1": "overflow는 주로 부모에서 사용하고",
    "p2": "자식요소가 넘치는 경우에 어떻게 처리할 것인지를 담당한다"
  },
  {
    "id":29,
    "headId": "css-float",
    "headHref": "#css-float",
    "headName": "float",
    "folder": "CSS",
    "picture": "css029float.png",
    "p3": "float는 요소를 띄어서 주로  왼쪽, 중간, 오른쪽에 배치하는 방법이다",
    "p6": "float는 나머지 요소가 주위에서 감싸는 특징이 있는데",
    "p7": "float의 속성값을 주는 순간부터",
    "p8": "그 요소는 block formatting context가 되기 때문에",
    "p9": "나머지 요소들도 block formatting context로 만들어주면",
    "p10": "서로 감싸지 안게 된다"
  },
  {
    "id": 30,
    "headId": "css-font",
    "headHref": "#css-font",
    "headName": "font",
    "folder": "CSS",
    "picture": "css030글자.png",
    "p1": "글자에서 정렬 부분은 중요한 테크닉이다",
    "p2": "가령, 네모박스안에서 글자를 정가운데에 배치하고 싶을때",
    "p3": "text-align과 line-height를 사용 할 수 있다"
  },
  {
    "id": 31,
    "headId": "css-backgournd",
    "headHref": "#css-backgournd",
    "headName": "backgournd",
    "folder": "CSS",
    "picture": "css031배경1.png",
    "p1": "배경은 크게 이미지와 색이 있다",
    "p2": "배경이미지는 우리가 아는 < img > 태그와는 다르다"
  },
  {
    "id": 32,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css032배경2.png",
    "p1": "배경이미지는 요소(예, 글자)라는 창틀 뒤에서 보여지는것이다!!",
    "p4": "이것이 < img > 태그와 다른 점이고",
    "p5": "공간의 크기는 요소(예, 글자)가 결정하는 것이다",
    "p6": "배경이미지랑 요소의 크기랑 다르기 때문에",
    "p7": "배경이미지가 모두 안보이거나",
    "p8": "배경이미지가 반복되는 현상들이 나타는데",
    "p9": "이를 해결하기위한 속성들이 사진의 4가지 속성들이다"
  },
  {
    "id": 33,
    "headId": "css-shadow",
    "headHref": "#css-shadow",
    "headName": "shadow",
    "folder": "CSS",
    "picture": "css033그림자.png",
    "p1": "그림자는 평면의 요소를 입체적으로 보여지게 하는",
    "p2": "매우 중요한 기술중 하나이다"
  },
  {
    "id": 34,
    "headId": "css-media-query",
    "headHref": "#css-media-query",
    "headName": "미디어 쿼리",
    "folder": "CSS",
    "picture": "css034미디어쿼리1.png",
    "p1": "너비에 따라 웹페이지의 레이아웃이 바뀐다",
    "p2": "지원하는 미디어는 크게 모니터와 프린터 정도 참고하자",
    "p6": "너비의 조건은 max,min-width를 이용해서 제한을 걸고",
    "p7": "{ } 안에 해당 조건에서의 레이아웃 스타일을 넣어주면 된다"
  },
  {
    "id": 35,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css035미디어쿼리2.png",
    "p1": "다양한 너비마다 조건을 다르게 주고싶을때",
    "p2": "미디어 쿼리를 여러개를 사용 할 수 있는데",
    "p3": "아래로 갈수록 너비는 작은값을 주고",
    "p4": "미디어 쿼리마다 바뀌는 class는 태그에 둘다 써주자"
  },
  {
    "id": 36,
    "headId": "css-transform",
    "headHref": "#css-transform",
    "headName": "transform",
    "folder": "CSS",
    "picture": "css036transform.png",
    "p1": "마지막으로 움직임에 대한 스타일이다",
    "p2": "요소가 그냥 움직일수도 있고",
    "p3": "사용자와 상호작용 (클릭, 접촉)으로 움직인다",
    "p6": "동적요소의 핵심은 시점에 따라",
    "p7": "다른 스타일 속성을 적용하여 움직이게 보이는 것이다",
    "p9": "transform은 요소를 변형시키는 방법을 제시한다"
  },
  {
    "id": 37,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css037transition.png",
    "p1": "transition은 스타일의 속성을 시간에 따라 바꾸어서",
    "p2": "마치 애니메이션처럼 보이게 해준다",
    "p4": "transition을 적용할 선택자에서",
    "p5": "어떤속성에 적용할지 정의를 해주고",
    "p6": "적용할 선택자:행동조건에서",
    "p7": "적용된 속성의 바뀔 값을 적으면 된다"
  },
  {
    "id": 38,
    "headId": "css-animation",
    "headHref": "#css-animation",
    "headName": "animation",
    "folder": "CSS",
    "picture": "css038animation.png",
    "p1": "애니메이션은 특정지점에서 스타일을 바꾸면서",
    "p2": "마치 움직이는 것처럼 보여지게 한다",
    "p4": "애니메이션을 적용할 선택자에서",
    "p5": "애니메이션 이름과 실행시간을 정의해주고",
    "p6": "키프레임을 정의하는 곳에서",
    "p7": "애니메이션의 이름과 속성값은 시점에 따라 어떻게 바꿀지 정의"
  }
]
