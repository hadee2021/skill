[
  {
    "id": 1,
    "headId": "css-big-picture",
    "headHref": "#css-big-picture",
    "headName": "CSS 개관",
    "folder": "CSS",
    "picture": "css001개관.png",
    "contentArr": [
      "css의 큰그림은 3가지 영역 입니다. <br><br>",
      "1. 기본 재료들<br><br>",
      "2. 재료들은 어떻게 배치할 것인가<br><br>",
      "-> 크기지정 vs 크기지정 X  <br><br>",
      "3. 화면크기에 따른 유동성과 요소의 동적 <br><br>"
    ]
  },
  {
    "id": 2,
    "headId": "css-factor",
    "headHref": "#css-factor",
    "headName": "요소, 부모 자식",
    "folder": "CSS",
    "picture": "css002요소부모자식.png",
    "contentArr": [
      "웹에 넣는 요소는 크게 3가지 입니다.<br><br>",
      "글자, 이미지, 빈칸(너비, 높이 지정 해야합니다.) <br><br>",
      "부모에서 자식으로 스타일이 전달 됩니다. <br><br>",
      "핵심은 스타일이 필요한 대상이 누구냐 입니다. <br><br>",
      "부모 -> 부모만 필요하거나 부모,자식 둘다 필요한경우 <br><br>",
      "자식 -> 자식만 필요한 경우 <br><br>",
      "스타일의 우선순위는 암기하면 좋습니다. <br><br>",
      "동일한 우선순위는 코드상위치가 아래로 갈 수록 우선적 입니다. <br><br>"
    ]
  },
  {
    "id": 3,
    "headId": "css-selector",
    "headHref": "#css-selector",
    "headName": "선택자",
    "folder": "CSS",
    "picture": "css003선택자1.png",
    "contentArr": [
      "누구에게 스타일을 적용할 것인가 tragetting하는게 선택자 입니다.<br><br>",
      "보통은 class를 이용하여 선택을 합니다. <br><br>",
      "렌더링을 위해서는 간단한 셀렉터를 사용합니다. <br><br>",
      "자식태그가 형제들로 나란히 있을때는 <br><br>",
      "기하적으로 선택을 해볼 수 있습니다. <br><br>"
    ]
  },
  {
    "id": 4,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css004선택자2.png",
    "contentArr": [
      "사용자의 행동조건에 따른 선택자도 있습니다.<br><br>",
      "예를들면, 커서를 올린다던지, 클릭을한다던지 ,등의 행동 <br><br>",
      "사용가능여부는 input태그와 연동하여 사용하기도 합니다. <br><br>",
      "부정은 그것빼고 적용하는 것인데 <br><br>",
      "이걸 대체할 수 있는 다른 선택자가 없다 합니다. <br><br>"
    ]
  },
  {
    "id": 5,
    "headId": "css-box",
    "headHref": "#css-box",
    "headName": "box",
    "folder": "CSS",
    "picture": "css005박스1.png",
    "contentArr": [
      "박스는 내용요소인 content가 있고<br><br>",
      "내용과 경계사이의 공간인 padding이 있습니다. <br><br>",
      "padding은 처음에는 없는 공간임을 명심 해야합니다.ㅍ",
      "( 예외적으로 li 태그에는 초기 padding이 존재하긴함 )<br><br>",
      "마지막으로 박스바깥은 margin 입니다.<br><br>",
      "margin은 블록의 레벨에따라 처음에 존재유무가 다릅니다.<br><br>",
      "inline, inline-block은 마진이 없습니다.<br><br>"
    ]
  },
  {
    "id": 6,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css006박스2.png",
    "contentArr": [
      "content -> 내용 요소 입니다.<br><br>",
      "너비와 높이를 변화시키면 크기변화 하는게 content 입니다<br><br>",
      "블록의 레벨에 따라 크기가 다르니 알아둬야 합니다.<br><br>"
    ]
  },
  {
    "id": 7,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css007박스3.png",
    "contentArr": [
      "padding -> content와 border사이 공간 입니다.<br><br>",
      "대부분 처음에는 없음을 알아 둬야 합니다.<br><br>",
      "padding의 크기변화시 경계의 길이가 변하는 것도 중요합니다. <br> <br>",
      "padding의 크기변화시 블록의 레벨에 따라<br><br>",
      "content의 크기에도 영향을 줄 수 있으니 알아 둬야 합니다.<br><br>"
    ]
  },
  {
    "id": 8,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css008박스4.png",
    "contentArr": [
      "border -> padding이 없으면 바로 content를 둘러 쌉니다. <br> <br>",
      "border상 하 좌 우 유무를 이용하면 border중첩현상을 방지 할 수 있습니다. <br> <br>",
      "cf) outline은 외곽선인데 outline-offset속성을 음수값을 주면<br><br>",
      "외곽선을 박스 안으로 사용 할 수 있습니다.<br><br>"
    ]
  },
  {
    "id": 9,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css009박스5.png",
    "contentArr": [
      "margin -> 박스바깥의 영역입니다. <br> <br>",
      "양쪽 마진은 서로 중첩되지 않고 밀어 냅니다. <br> <br>",
      "상,하 마진은 서로 중첩이되어 겹치게 됩니다. <br> <br>"
    ]
  },
  {
    "id": 10,
    "headId": "css-width-height",
    "headHref": "#css-width-height",
    "headName": "width, height",
    "folder": "CSS",
    "picture": "css010너비높이.png",
    "contentArr": [
      "너비와 높이는 크기!!! 를 부여하는 매우 중요한 친구들 이다 <br> <br>",
      "단위는 고정값과 상대값이 있는데<br><br>",
      "무조건 그 크기만 사용하려면 고정값을 쓰면되고 <br> <br>",
      "화면이나 다른 요소에 대해 상대적으로 크기를 지정하고 싶으면<br><br>",
      "상대값을 사용하면 된다 <br> <br>",
      "상대값은 단위마다 누구를 기준으로 할지 중요하다<br><br>"
    ]
  },
  {
    "id": 11,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css011maxmin.png",
    "contentArr": [
      "너비와 높이의 max,min도 매우 중요하다 <br> <br>",
      "max,min은 요소에 제한을 거는것으로 가장 우선시된다 <br> <br>",
      "우선시??!!",
      "요소의 크기를 지정할때 여러가지 속성이 겹치게 되는 일이 발생하는데",
      "이 경우에 누가 요소의 크기를 우선적으로 결정하냐가 포인트이다!!"
    ]
  },
  {
    "id": 12,
    "headId": "css-var",
    "headHref": "#css-var",
    "headName": "변수",
    "folder": "CSS",
    "picture": "css012변수.png",
    "contentArr": [
      "css변수는 전역으로 사용하는 방법과 로컬로 사용하는 방법이 있다 <br> <br>",
      "전역 -> :root 를 사용하여 지정하고",
      "로컬 -> 부모에서 지정하여 자식에서 사용하는 방식이다 <br> <br>",
      "변수는 색상을 약속된 값으로 사용하는 파렛트에 사용하거나",
      "calc처럼 숫자 계산을 할 때 사용한다"
    ]
  },
  {
    "id": 13,
    "headId": "css-flex",
    "headHref": "#css-flex",
    "headName": "flex",
    "folder": "CSS",
    "picture": "css013플렉스박스1.png",
    "contentArr": [
      "그림에서 약속 하나 하고 가자!!",
      "flex를 지정하는 파란색판을 flex판이라 하고",
      "그 안의 빨간색 상자는 box라고 하자 <br> <br>",
      "flex는 공간배치를 수월하게 도와주는데",
      "flex판 안의 box크기를 지정한것 vs 크기 지정 안한것 차이가 있다",
      "앞서 크기 지정여부가 중요하다고 강조한 이유가 이런 detail의 차이 때문이다 <br> <br>",
      "flex가 배치를 하기 위해서는 당연히 기준이 필요하다!!",
      "그 기준이 바로 box의 배열 방향을 결정하는 주축",
      "그리고 주축과 교차하는 방향의 교차축"
    ]
  },
  {
    "id": 14,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css014플렉스박스2.png",
    "contentArr": [
      "flex박스는 크게 2가지 절차가 있다",
      "1st. 순서",
      "2nd. 정렬방법 <br> <br>",
      "주축의 방향은 가로인가 세로인가",
      "1줄만 -> 박스의 크기합이 flex판보다 큰 경우에는 n등분이된다"
    ]
  },
  {
    "id": 15,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css015플렉스박스3.png",
    "contentArr": [
      "2nd. 정렬방법 <br> <br>",
      "justify = 주축에 대한 정렬",
      "align = 교차축에 대한 정렬"
    ]
  },
  {
    "id": 16,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css016플렉스박스4.png",
    "contentArr": [
      "주축에 대한 정렬방법은",
      "주로 justify-content를 사용한다 <br> <br>",
      "정렬의 유형은 사진 참고"
    ]
  },
  {
    "id": 17,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css017플렉스박스5.png",
    "contentArr": [
      "교차축에 대한 정렬방법은",
      "크게 3가지 방식을 사용한다 <br> <br>",
      "align-content는 justify-content와 흡사 해보인다"
    ]
  },
  {
    "id": 18,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css018플렉스박스6.png",
    "contentArr": [
      "align-items는 3가지 방식중 많이 사용한다고 한다 <br> <br>",
      "왜냐, align-content와 달리 start, end, center에서",
      "서로간 간격을 내기 좋기 때문이다"
    ]
  },
  {
    "id": 19,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css019플렉스박스7.png",
    "contentArr": [
      "align-self는 자식에서 사용하는 속성이다 <br> <br>",
      "플렉스의 보라색 영역에서 각각의 줄마다 내부적으로 배치함"
    ]
  },
  {
    "id": 20,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css020플렉스박스8.png",
    "contentArr": [
      "box의 크기를 지정하지 않은 경우는 어떨까??",
      "물론 box안의 내용요소들 (예, 문자 )의 크기는 있다",
      "허나, 중요한건 box공간은 별도로 크기를 주지 안은게 핵심이다 <br> <br>",
      "flex: 1 이라는 속성을 이용하면",
      "flex판의 주축방향을 n등분하여 나눠줄 수 있다",
      "근데, 이렇게 되면 1줄만 box들이 가득차게 된다 <br> <br>",
      "앞서 배운 min-width를 사용하면",
      "box의 크기는 최소한도 너비를 가지게 되어서",
      "다음줄로 밀려나게 된다"
    ]
  },
  {
    "id": 21,
    "headId": "css-grid",
    "headHref": "#css-grid",
    "headName": "grid",
    "folder": "CSS",
    "picture": "css021그리드1.png",
    "contentArr": [
      "그리드는 컨테이너의 공간을 나눠사용하는 것이다.<br> <br> <br> <br>"
    ]
  },
  {
    "id": 22,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css022그리드2.png",
    "contentArr": [
      "그리드에서도 약속 하나 하자면",
      "빨간색 상자를 gird판이라고 하고 부모요소라 하자",
      "그안에 자식으로 공간이 들어간다 까지 <br> <br>",
      "그리드 항목공간의 너비와 높이를 지정해주는데",
      "상대값은 fr을 이용하여 비율로 표현 가능하다 <br> <br>",
      "grid-template-columns는 width와 가로의 의미가 있는데",
      "결국은 1줄에 몇개공간 쓰고 각 공간 너비가 얼마냐를 지정해주는 것이다 <br> <br>",
      "flex와 구별되는 특징이라면",
      "그리드 항목간에의 간격을 내 맘대로 조정이 가능하다"
    ]
  },
  {
    "id": 23,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css023그리드3.png",
    "contentArr": [
      "여러줄이 있고 마치 셀병합을 한 것 처럼",
      "그리드 항목 공간을 사용하고 싶을 때!! <br> <br>",
      "grid-template-area를 사용 할 수 있다 <br> <br>",
      "\"  \"를 이용하여 1줄을 표현하고",
      "시각적으로 구성 할 수 있다는 점에서 유용하다"
    ]
  },
  {
    "id": 24,
    "headId": "css-containing-block",
    "headHref": "#css-containing-block",
    "headName": "containing block",
    "folder": "CSS",
    "picture": "css024컨테이닝블록.png",
    "contentArr": [
      "부모는 조건이 맞아야 자식을 감쌀 수 있다",
      "그게 아니라면 자식요소의 크기가  큰 경우",
      "부모의 밖으로 넘치는 현상이 발생할 수 있다 <br> <br>",
      "containing block은 누가 부모인가를 결정 하는 것이다",
      "가령, 크기의 상대단위인 %는 부모를 기준으로 크기를 결정하는데",
      "무조건 상위의 요소가 부모는 아니기 때문이다",
      "그리고 필요하다면 그 상위의 요소가 부모의 역할이 되게 만들어야지",
      "자유자재로 배치 할 수 있다 <br> <br>",
      "이따 다룰거지만 position 속성을 기준으로 containing block를 정한다",
      "position의 기본값은 static이고",
      "이들은 우리가 흔히 알듯이 상위의 요소가 부모들이다",
      "하지만 absolute는 static이 부모가 될 수 없어서",
      "우리가 아는 상위요소를 부모로 보았다가는 원하는 배치를 하기 힘들어진다",
      "그래서 공식처럼 absolute를 사용하려면 상위요소에 relative를 넣어서",
      "그 상위요소를 부모로 만드는것이 이러한 이유이다"
    ]
  },
  {
    "id": 25,
    "headId": "css-block-formatting-context",
    "headHref": "#css-block-formatting-context",
    "headName": "block formatting context",
    "folder": "CSS",
    "picture": "css025블록포멧팅.png",
    "contentArr": [
      "block formatting context는 어디까지가 자식인가 <br> <br>",
      "이따 다룰거지만 overflow의 경우 기본값이 visible인데",
      "visible은 자식으로 취급하지 않는다",
      "이런경우에 자식의 요소가 부모 보다 크기가 커서 넘치는경우가 발생함","( 예외적으로 li 태그에는 초기 padding이 존재하긴함 )<br><br>",
      "그래서 overflow를 auto혹은 scroll등으로 바꿔주는 것이다"
    ]
  },
  {
    "id": 26,
    "headId": "css-position",
    "headHref": "#css-position",
    "headName": "position",
    "folder": "CSS",
    "picture": "css026포지션1.png",
    "contentArr": [
      "position은 요소가 위로 떠버린다",
      "css 코드상의 위치가 아래로 갈 수록 더 위로 뜬다",
      "z-index의 높은숫자로 조절가능함 <br> <br>",
      "position은 주로 자식에 적용을 하는데",
      "절대위치와 상대위치가 있다"
    ]
  },
  {
    "id": 27,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css027포지션2.png",
    "contentArr": [
      "사진에서 중요하게 봐야할 포인트는 2가지이다!! <br> <br>",
      "1. 누구를 기준으로 위치를 정하는가",
      "2. 다른요소에 영향을 주는가"
    ]
  },
  {
    "id": 28,
    "headId": "css-overflow",
    "headHref": "#css-overflow",
    "headName": "overflow",
    "folder": "CSS",
    "picture": "css028overflow.png",
    "contentArr": [
      "overflow는 주로 부모에서 사용하고",
      "자식요소가 넘치는 경우에 어떻게 처리할 것인지를 담당한다"
    ]
  },
  {
    "id":29,
    "headId": "css-float",
    "headHref": "#css-float",
    "headName": "float",
    "folder": "CSS",
    "picture": "css029float.png",
    "contentArr":[
      "float는 요소를 띄어서 주로  왼쪽, 중간, 오른쪽에 배치하는 방법이다 <br> <br>",
      "float는 나머지 요소가 주위에서 감싸는 특징이 있는데",
      "float의 속성값을 주는 순간부터",
      "그 요소는 block formatting context가 되기 때문에",
      "나머지 요소들도 block formatting context로 만들어주면",
      "서로 감싸지 안게 된다"
    ]
  },
  {
    "id": 30,
    "headId": "css-font",
    "headHref": "#css-font",
    "headName": "font",
    "folder": "CSS",
    "picture": "css030글자.png",
    "contentArr": [
      "글자에서 정렬 부분은 중요한 테크닉이다",
      "가령, 네모박스안에서 글자를 정가운데에 배치하고 싶을때",
      "text-align과 line-height를 사용 할 수 있다"
    ]
  },
  {
    "id": 31,
    "headId": "css-backgournd",
    "headHref": "#css-backgournd",
    "headName": "backgournd",
    "folder": "CSS",
    "picture": "css031배경1.png",
    "contentArr":[
      "배경은 크게 이미지와 색이 있다",
      "배경이미지는 우리가 아는&lt; img &gt; 태그와는 다르다 <br> <br>"
    ]
  },
  {
    "id": 32,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css032배경2.png",
    "contentArr": [
      "배경이미지는 요소(예, 글자)라는 창틀 뒤에서 보여지는것이다!! <br> <br>",
      "이것이 &lt; img &gt; 태그와 다른 점이고",
      "공간의 크기는 요소(예, 글자)가 결정하는 것이다 <br> <br>",
      "배경이미지랑 요소의 크기랑 다르기 때문에",
      "배경이미지가 모두 안보이거나",
      "배경이미지가 반복되는 현상들이 나타는데",
      "이를 해결하기위한 속성들이 사진의 4가지 속성들이다"
    ]
  },
  {
    "id": 33,
    "headId": "css-shadow",
    "headHref": "#css-shadow",
    "headName": "shadow",
    "folder": "CSS",
    "picture": "css033그림자.png",
    "contentArr": [
      "그림자는 평면의 요소를 입체적으로 보여지게 하는",
      "매우 중요한 기술중 하나이다"
    ]
  },
  {
    "id": 34,
    "headId": "css-media-query",
    "headHref": "#css-media-query",
    "headName": "미디어 쿼리",
    "folder": "CSS",
    "picture": "css034미디어쿼리1.png",
    "contentArr": [
      "너비에 따라 웹페이지의 레이아웃이 바뀐다 <br> <br>",
      "지원하는 미디어는 크게 모니터와 프린터 정도 참고하자 <br> <br>",
      "너비의 조건은 max,min-width를 이용해서 제한을 걸고",
      "{ } 안에 해당 조건에서의 레이아웃 스타일을 넣어주면 된다"
    ]
  },
  {
    "id": 35,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css035미디어쿼리2.png",
    "contentArr": [
      "다양한 너비마다 조건을 다르게 주고싶을때",
      "미디어 쿼리를 여러개를 사용 할 수 있는데",
      "아래로 갈수록 너비는 작은값을 주고",
      "미디어 쿼리마다 바뀌는 class는 태그에 둘다 써주자"
    ]
  },
  {
    "id": 36,
    "headId": "css-transform",
    "headHref": "#css-transform",
    "headName": "transform",
    "folder": "CSS",
    "picture": "css036transform.png",
    "contentArr": [
      "마지막으로 움직임에 대한 스타일이다",
      "요소가 그냥 움직일수도 있고",
      "사용자와 상호작용 (클릭, 접촉)으로 움직인다 <br> <br>",
      "동적요소의 핵심은 시점에 따라",
      "다른 스타일 속성을 적용하여 움직이게 보이는 것이다 <br> <br>",
      "transform은 요소를 변형시키는 방법을 제시한다"
    ]
  },
  {
    "id": 37,
    "headId": "",
    "headHref": "",
    "headName": "",
    "folder": "CSS",
    "picture": "css037transition.png",
    "contentArr": [
      "transition은 스타일의 속성을 시간에 따라 바꾸어서",
      "마치 애니메이션처럼 보이게 해준다 <br> <br>",
      "transition을 적용할 선택자에서",
      "어떤속성에 적용할지 정의를 해주고 <br> <br>",
      "적용할 선택자:행동조건에서",
      "적용된 속성의 바뀔 값을 적으면 된다"
    ]
  },
  {
    "id": 38,
    "headId": "css-animation",
    "headHref": "#css-animation",
    "headName": "animation",
    "folder": "CSS",
    "picture": "css038animation.png",
    "contentArr": [
      "애니메이션은 특정지점에서 스타일을 바꾸면서",
      "마치 움직이는 것처럼 보여지게 한다 <br> <br>",
      "애니메이션을 적용할 선택자에서",
      "애니메이션 이름과 실행시간을 정의해주고 <br> <br>",
      "키프레임을 정의하는 곳에서",
      "애니메이션의 이름과 속성값은 시점에 따라 어떻게 바꿀지 정의 <br> <br> <br> <br>"
    ]
  }
]
